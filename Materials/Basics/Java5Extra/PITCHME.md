Java

+++

+++

___

Исключения

+++

@snap[west]
Исполнение программы не всегда является предсказуемым. Бывают ситуация, когда при выполнении определенного блока кода возникают ошибки(часто которые мы ожидаем увидеть здесь) из-за некоторых независящих от программиста обстоятельств. У программы нет соедениения с интеренетом и она не в состоянии подгрузить необходимую информацию, из-за чего выполнение дальнейших инструкций становится невозможным. В таких ситуациях требуется правильно подготовиться к возникновению таких ошибок

@snapend
+++
@snap[north-west]
Примеры таких ошибок
@snapend

@snap[north-west]
@ol
- Не отвечает сервер
- Не отвечает база данных
- Файл который хочет открыть пользователь не существует в системе
- Пользователь ввел данные неверного формата. Например программа не смогла интерпретировать введенную дату или номер телефона и т.д.
@olend
@snapend
+++

@snap[north-west]
@ol
- Unchecheked exeptions - проблемы возникающие во время исполнения программы (runtime), которые игнорируются на уровне компиляции программы. Это могут быть логические ошибки, проблемы с архитектурой или неправильное использование API

- Errors - проблемы возникающие за пределеами досигаемости пользователя программы или разработчика. Например могут возникнуть проблема с процессором или с JVM
@olend
@snapend

+++
Картинка
+++ 
@snap[north-west]
Ключевые слова
@snapend

@snap[west]
@ol
- try {} - "попробуй" исполнить код в блоке, и если там возникнут исключения, остановить исполнение этого блока, так где возникла проблема
- catch(exeptionType exeption){} - исполнить код в блоке, если в блке try возникло исключение exeptionType
- finally(){} - блок который будет исполнен всегда, после завершения блока try{} или любого блока catch{} 
@olend
@snapend
+++

@snap[north]
Пример обработки исключения
@snapend
```Java
Int[] array = {1, 2, 3, 4};

try {
	int element = array[10];
}
catch(ArrayIndexOutOfBoundsException e) {
	System.out.println("ERROR:" + e);
}
finally {
	System.exit(0);
}
```
@[1](Наш массив состоит всего из 4ех элементов. Максимально возможный индекс здесь - 3)
@[4](При попытке сделать так, программа сломается и остановит выполнения работы)
@[3-4](Но в нашем случае мы делаем это в блоке try. Инструкция не сможет сработать, но вместо завершения работы программы мы сможем восстановиться от такой ошибки т.к. делаем это в блоке try)
@[6-7](Блок который срабатывает при ArrayIndexOutOfBoundsException. Это исключение которое как раз и возникнет при попытке прочесть 11ый элемент массива)
@[9-11](После чего сработает финальный блок, который завершит программу с системным кодом 0)
+++

Если в java строгое отношение к тому, что именно возвращает метод, то как именно должен звершаться метод который столкнулся с проблемой и должен остановить свое выполнение бросив исключение? Этот метод все равно должен что-то вернуть или же сообщить о некой проблеме?


+++
@snap[north-west]
Оператор `throw`
@snapend

@snap[west]
Метод, у которого возникла нештатная ситуация не в состоянии вернуть что-либо. Вместо этого он "бросает" исключение, написанное программистом. Для этого используется оператор `throw`, который в такой ситуации является аналогом оператору `return`. Также очевидно, что если метод имеет "альтернативу оператору return" то об этом стоит сообщить заранее во время объявление метода
@snapend 

+++

@snap[north]
@snapend

```Java
public String someMethod(int id) throws IllegalAccessException{
	if id == 0 {
		System.out.println("Everuthing is ok");
		return "Ok";
	} else {
		System.out.println("Wrong id!");
		throw IllegalAccessException
	}
}
```


+++
@snap[west]
Кроме использования исключений из коробки, разработчки может определять свои, и "кидать" их, тогда, когда считает, что нормально выполнения работы методы дальше невоможно. Для того, чтобы создать свое исключение, достаточно наследовать свой класс от класса `exeption`
@snapend

+++

```Java
public class CustomExeption extends Exeption {
	CustomExeption(){}
}
```

+++

```Java

```
___

Класс __File__

Объект класса __File__ из встроенной библиотеки __java.io__ представляет собой директорию или файл операционной системы. 


---

Коллекции

+++

Коллекции - иерархия отедельных интерфейсов из коробки. Каждый интерфейс предназначен для реализации отдельной классической структуры данных. Две основные группы таких интерфейсов - `Collection` и `Map`

+++

Картинка

+++

`Map` - __неупорядоченная__ последовательность пар __"ключ" - "значение"__. __Ключ__ - аналог индекса у массивов, только вместо целочисленной переменной используются другие типы данных, например, строковые. В качестве значений может использоваться любой тип данных. К реализациям `map` относятся `Hashtable`, `HashMap`, `LinkedHashMap`, `TreeMap`, `WeakHashMap`.

+++

`HashMap` - основная реализация. Основана на хештаблице. Набор пар "ключ" - "значение".
`LinkedHashMap` - реализация хештаблицы на основе связных списков
`TreeMap` - реализация на основе деревьев

+++

```Java
HashMap<String, String> passwords = new HashMap<String, String>();

passwords.put("Aleksey", "12345");
passwords.put("Boris", "qwerty");
passwords.put("Andrei","1111");

String password = passwords.get("Aleksey");
passwords.remove("Boris");
``` 

+++

`Collection` - набор каких-либо элментов. Реализацию бывают как упорядоченные (есть строгая последовательность элементов и можно обрашаться к элементам по индексу) так и неупорядоченные. К реализациям относятся `Set`(множество), `List`(список) и `Queue`(очередь)

+++

Список

К реализациям списка относятся

- `ArrayList` - реализация динамического массива (массива, размер которого изменяется автоматического) 
- `LinkedList` - реализация связного списка. Каждый элемент такого списка хранит не только сами данные но и ссылку на следующий (иногда предыдущий) элемент массива
- `Vector` - устарел
- `Stack` - реализация классического стека

+++

Пример использования ArrayList

```Java
ArrayList<String> lessons = ArrayList<String>();

lessons.add("English");
lessons.add("CS");
lessons.add("Math");

lessons.remove("CS");

String myLesson = lessons.get(1);

for(String lesson: lessons){
	System.out.println(lesson);
}
```

+++
