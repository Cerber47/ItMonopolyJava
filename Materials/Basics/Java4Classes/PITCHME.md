# Классы и объекты
+++
С помощью примитивных типов можно описать числа, строки и множество других вещей. Но как описывать сложные структуры данных и хранить их в одной переменной? Например мы хотим хранить информацию о студенете и создавать несколько студентов, если потребуется

+++

КАРТИНКА

+++

Для такой задачи мы бы хотели описать свой __тип__ данных, который содержал бы в себе внутренние переменные. Для таких целей в Java существует понятие __класса__

+++

@snap[north-west]
Класс
@snapend 

@snap[west]
Класс описывает содержание и поведение некой совокупности данных и внешних действий над этими данными. Простым языком, класс -это некоторый шаблон данных, или просто набор переменных и функций. Переменные класса называют полями, аттрибутами, пропертями или свойствами. Функции класса называют методами
@snapend

+++

@snap[north]
Объявление класса
@snapend

```Java
class StudentInfo{
	int id;
	String name;
	int age;
	int year;
	String course;
}
``` 
@[1](Объявление класса начинается с оператора `class` и названия класса. В нашем случае класс имеет название StudentInfo)
@[2-6](Далее мы указываем, что наш класс имеет 5 переменных, которые будут принадлежать данному классу)

+++

Объявив класс или, другими словами, описав наш "новый тип", мы можем создавать переменные такого "типа" или класса. Работают с объектами, а не с классами!

+++

@snap[north-west]
Объект
@snapend

@snap[west]
__Объект__ - это экземпляр класса. Если класс это описание, то объект это непосредственно то с чем можно работать. Переменные и функции объекта становятся доступными через точку. Переменные объекта можно читать, переопределять значения, а функции вызывать.
@snapend

+++

@snap[north]
Создаем объект оператором new
@snapend

```Java
StudentInfo student_Aleksey;
student_Aleksey = new StudentInfo();
student_Aleksey.id = 0;
student_Aleksey.name = "Aleksey"

StudentInfo student_Fedor = new StudentInfo();
student_Fedor.id = 1;
student_Fedor.name = "Fedor"
```
@[1](Объявляем переменную student_Aleksey класса StudentInfo)
@[2](Инициализируем объект класса StudentInfo с помощбю оператора new)
@[3-4](Задаем полям id и name объекта student_Aleksey значения 0 и "Aleksey" соответсвенно)
@[6-8](Аналогично можем создаьть еще один объект класса Student_info и задать уже другие значения)

+++

@snap[north]
Класс vs объект
@snapend

КАРТИНКА

+++

@snap[north-west]
Методы
@snapend

@snap[west]
Функции класса нзываются методами. Работают как обычные функции. Чтобы вызвать метод вне класса, требуется прописать имя объекта и через точку указать имя вызываемой функции(метода). Внутри класса можно пользоваться методами класса обычным способом

+++

@snap[north]
Объявление метода
@snapend

```Java
class StudentInfo{
	int id;
	String name;
	int age;
	int year;
	String course;

	public void printInfo(){
		System.out.println(name);
	}
}
```
@[8](Объявляем метод printInfo класса StudentInfo)
@[3,9](Метод распечатывает на экран переменную name объекта)

+++

@snap[north]
Вызов метода
@snapend

```Java
StudentInfo student = new StudentInfo();
student.id = 0;
student.name = "Aleksey";

student.printInfo(); // Напечатает Aleksey
```
@[1-3](Создаем объект класса StudentInfo с именем student)
@[5](Вызываем метод printInfo объекта  student)

+++

@snap[nort-west]
Разобраться
@snapend

Открыть ScopeExample.java и разобраться в том, как работает область видимости переменной. Объяснить результат работы каждого метода класса `Example`

+++

@snap[west]
@ol
- Переменные класса видны всем методам этого класса
- Если эта переменная `public` то она видна и за пределами класса
- Если у метода есть переменная с названием, совпадающим с переменной класса, то компилятор будет рабоать именно с локальной переменной.(Правило ближайшего объявления)
- Аргументы также работают как и локальные переменные
- Когда требуется указать, что речь идет именно о переменной класса используют особое слово `this`
- `this` - это указание на этот экземпляр. Он работает так же как и обычные объекты вне класса - все переменные и методы указываются через точку посе слова 'this'
@olend
@snapend

+++

Полную реализацию программы по этой теме смотрите в файле StudentDataBase.java. 

--- 

# Конструкторы

+++

```Java
class Device{
	int id;
	String name;
	double price;
}
public class DeviceStore{
	public static void main(String[] args){
		Device newDevice = new Device();

		newDevice.id = 0;
		newDevice.name = "Macbook";
		newDevice.price = 1000.0;
	}
}
```

+++

@snap[north]
Так делать плохо. Почему?
@snapend

@snap[west]
@ol
- Неудобно. Тратим по строчке кода на каждое поле объекта
- Можно случайно забыть определить важный атрибут объекта
- Нет гарантии что все необхоимые поля объекта определены. Например другой метод может использовать эти переменные, думая, что они имеют значения, а пока мы гарантировать это не можем 
@olend
@snapend

+++

```Java 
class Device{
	int id;
	String name;
	double price;
	Device(int id, String name, double price){
		this.id = id;
		this.name = name;
		this.price = price;
	}
public class DeviceStore{
	public static void main(String[] args){
		Device newDevice = new Device(0, "Macbook", 1000.0);
	}
}
```

@[1,5](Создаем функцию с таким же именем. Она будет вызываться всегда при создании нового объекта)
@[12](Вот таким образом мы вызываем нашу функцию создания объекта)

+++

@snap[north-west]
Конструктор
@snapend

@snap[west]
__Конструктор__, или __инициализатор(initializer)__ - метод, который вызывается всегда, когда создается новый эксземпляр класса. Это обычно метод, который определяет все необходимые переменные для работоспособности класса. Происходит некая первоначальная "настройка" объекта. Конструктор гарантировано отрабатывает __до__ любой манипуляии над объектом. Имя конструктора должно совпадать с названием класса.
@snapend

+++

Реализация программы с активным использованием конструкторов можно найти в файле DeviceStore.java 

---

# Статические переменные и методы

+++

@snap[west]
Ключевое слово `static` используется для указания на то, что переменная или метод класса является __статичным__. Это означает, что метод или переменная принадлежит не экземпляру класса, а самому классу. Использовать такие переменные и методы можно как от класса, так и от экзепляров класса
@snapend

+++

```Java
class MyClass {
	static int luckyNumber = 11;
}

public class MyMainClass {
	MyClass myObj = new MyClass();

	System.out.println(myObj.luckyNumber);
	System.out.println(MyClass.luckyNumber);
}
```
@[3](Создаем класс со статичной переменной luckyNumber)
@[6](Создаем экземпляр этого класса с названием myObj)
@[8-9](Код на обеих строчках делает одно и тоже. Разницы просто нету)

+++

Почему главная функция(`main()`) главного класса является именно статической? Почему она не может быть не статической?

+++

@snap[west]
Статические переменные и методы используются для всевозможных трюков и приемов. Например выстраиваение архитектуры приложения, реализации паттернов программирования или глобальных переменных
@snapend

+++

@snap[north]
Реализация глобальной переменной
@snapend

```Java
class Settings {
	public static Color fontColor = new Color(255.0, 0.0, 0.0, 1.0);
	public static Font font = new Font("Comic Sans");
	public static Int textSize = 15; 
}
```
@[1-4](Объявленный таким образом класс можно использовать БЕЗ создания экземпляров)
@[2-4](Доступ к значениям таких констант получает любой объект в программе)
@[2](Например для того чтобы узнать цвет, будет достаточно написать Settings.fontColor)

+++

@snap[west]
Другим примером использования статических переменных и методов является паттерн __синглотон__. Паттерн синглтон гарантирует, что у объекта есть только один экземпляр и к нему есть глобальная точка доступа  
@snapend

+++

```Java
class Singleton {
	private static Singleton instanse;

	private Singleton() {
	}

	public static Singleton getInstanse(){
		if (instanse == null) {
			instanse = new Singleton();
		}
		return instanse
	}
}
```
@[2](Пересенная instance, которая хранит экземпляр этого класса)
@[4](Приватный конструктор. Выхвать его может только сам SInglton)
@[7](Метод, который возвращает экземпляр этого класса)
@[8-9](Если экземпляр ни разу еще не был создан - создать)
@[11](Возвращаем экземпляр этого класса)

+++

# Инкапсуляция 

+++

@snap[north-west]
Инкапсуляция
@snapend

@snap[west]
Мероприятия по сокрытию данных или методов от сторонних сущностей назвается __инкапсуляцией__. Инкапсуляция нужна, когда мы хотим ограничить доступ к методам и переменным. Часто выделяются переменные и методы, которыми может управлять лишь сам экземпляр класса, и те переменные и методы которые выступают в качестве интерфейса этого класса
@snapend

+++

КАРТИНКА

+++

@snap[north]
Модефикаторы доступа
@snapend

ТАБЛИЦА

+++

```Java
class 
```

+++

Если метод или переменная относятся к внутренним процессам внутри класса или не имеют отношения к внешним сущностям - это ошибка не объявлять этот метод как `private`! Не забывайте размышлять о том, является этот метод или переменная приватной или публичной, во всех случаях.

+++

@snap[north-west]
Геттеры и сеттеры
@snapend

@snap[west]

@snapend

+++

---
Полиморфизм
+++
__Полиморфизмом__ называют способность функций обрабатывать данных разных типов. Стоит выделять так называемый параметрический полиморфизм и специальный полиморфизм. Для __параметрического__ полиморфизма свойственно выполнение одного блока кода для потенциально разных по типу входных параметров, а для __специального__ - разных блоков кода для каждого отдельного типа входных данных 
+++

В java две функции могут иметь одинаковые названия, если они отличаются наборами аргументов. 

+++

---
Интерфейсы

Интерфейс - описание того, как должен выглядить класс, какие методы(часто без реализации) должен содержать класс, собирающийся "реализовывать" данный интерфейся. Любой класс может заявить, что он реализует интерфейся. В таком случае он обязан р