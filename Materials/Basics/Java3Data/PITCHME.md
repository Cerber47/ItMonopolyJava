@snap[north-west]
Data
@snapend

# Основы Java

---
## Массивы
+++
@snap[north-west]
__Массив__(англ. array) - структура данных, храняшая набор значений, которые именуются __элементами массива__, индентифицируемых по __индексам__(англ. index). Другими словами, это набор элементов одного типа с номерами, идущими друг за другом. Для того чтобы получить доступ к элементу массива, необходимы имя массива и порядковый номер(индекс)
@snapend

+++
@snap[north]
Объявление массива
@snapend
```Java
int normalInt;

int[] numbersArray;
double[] doublesArray;
boolean[] booleansArray;
String[] stringsArray;

numbersArray = new int[10];
int[] newArray = new int[20];
int[] anotherArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```
@[1](Так объявляются обычные переменные)
@[3](Добавляя [] к типу мы получаем массив int'ов)
@[4-6](Аналогичным образом мы можем объявить массивы любых типов, например строк даблов или булиновских переменных)
@[8](С помощью оператора new происходит выдение памяти под наш массив. В данном случае мы выделяем память под 10 int'ов)
@[9](Аналогично для массива, который будет хранить 20 элементов)
@[10](Массив объявить и инициализировать можно и таким интересным образом)

+++
@snap[north-west]
Доступ к элементу
@snapend

@snap[west]
- Чтобы прочитать или записать элемент массива нужен индекс или порядковый номер этого элемента
- Нумерация элементов в массиве начинается с 0!!!
- Нельзя обрашаться к несуществующему элементу! То есть, если в массиве 10 элементов, обращение к 11ому завершится ошибкой
- Нельзя обрашаться к пустому элементу массива. Если мы объявили массив и даже выделили под него память, но не инициализировали его значениями, чтение его элементов закончится ошибкой
@snapend

+++

@snap[north]
Заполнения всех элементов массива некоторым правилом
@snapend

```Java
int[] array = new int[5];

for(int i=0;i<array.length;++i){
	array[i] = i * 2 + 1;
}
```
@[1-5](Для примера в качестве правила заполнения будем использовать заполнение нечетными числами. Функция заполнения может быть любая)
@[1](Создаем массив из целых чисел с именем array и размером 5)
@[3-4](Заполнять массив всегда приходится циклом т.к. мы должны обратиться к каждому его элементу по отдельности)
@[3](При первой итерации i=0. Условие выхода из цикла, когда мы дойдем до последнего индекса массива. В данном случае это 4. Шаг итерации - +1)
@[4](В качестве функции исполтзвуем i*2+1. На первой итерации i==0, а значит мы в array[0] записываем 1)
@[3](Дальше происходит увеличение i на 1. На этой итерации i==1)
@[4](Теперь в элемент массива array[1] мы кладем уже 3)
@[3](Снова происходит увеличение i на еденицу. Так происходит до тех пор, пока мы не получим массив заполненный {1,3,5,7,9})

+++

Упражнение. Заполнить массив из 10 элементов подряд идущими четными числами начиная с 2. Заполнить массив нулями. Заполнить такой массив кубами, начиная от 1.
+++

@snap[north]
Печать всех элементов массива
@snapend

```Java
for(int i=0;i<array.length;++i){
	System.out.println(array[i]);
}
```
@[1](В начале i==0. Размер массива определяет выхрд из цикла. Шаг - еденица)
@[2](Если i==0, то мы распечатаем елемент array[0] или первый элмент)
@[1](Происходит увеличение i на 1. Теперь i==1)
@[2](Теперь происходит выврд элмента array[1])
@[1-2]

+++

@snap[north-west]
Цикл foreach
@snapend

@snap[west]
Цикл foreach работает аналогично циклу `for`, только в качестве итератора выступает не целочисленная переменная, а переменная, которая принимает все значения элементов массив в порядке представленном в массиве. 
@snapend

@snap[south]
\* Несмотря на такое путающее название такому циклу соответвует такой же оператор `for` но с другой синтаксической конструкцией
@snapend

---

## Строки

+++

@snap[north-west]
Строка
@snapend

@snap[west]
__Строка(англ. String)__ - структура данных, состоящий из последовательности символов. С помощью строк описываются текстовые данные. В java строки представлены классами `String`, `StringBuilder` и `StringBuffer`.
@snapend
+++
@snap[north-west]
Инициализирование строк
@snapend

```Java
String spell = "Abrakadabra";
```

+++
@snap[north-west]
Форматирование
@snapend

@snap[west]
Вывод строковых данных осуществляется классом `System.out`. С этой задачей справляются методы `println()`, `print()` и `printf()`.
@ol
- `print()` - выводит строку на экран
- `println()` - выводит строку на экран и добавляет `\n`
- `printf()` - выводит отформатированную строку на экран
@olend
@snapend

+++
@snap[north-west]
Форматирование 
@snapend

+++
@snap[north-west]
Пример форматирования
@snapend

```Java
String stringToFormat = "Name:%s(%d) Age:%d. Occupation:%s.";

System.out.pritntf(stringToFormat, "Aleksey", 24, "russian");
```
+++
@snap[north-west]
Аналогично этому работает метод `String.format()`
@snapend

```Java
String stringToFormat = "Hello %2$s. Last time youve been here %1$5.2ds ago";
String formatedString = String.format(stringToFormat, 13241.5789100 ,"Username");

System.out.println(formatedString);
```
+++
Методы строк
+++
@snap[north-west]
Определение длины
@snapend

@snap[west]
Метод `length()` возвращает количество символов в строке. Таким образом длина строки `"Small string"` равна 12, а длина строки `"A very large text with newline at the end\n"`- 42. Обратите внимание на символы `\n` и `\t` считаются за один символ!
@snapend

@snap[south]
@small(
\*Важно понимать, что современные ЯП считают длину строки иначе!
)
@snapend
+++
@snap[north]
Преобразование строки в массив
@snapend

```Java
String stringToStore = "This string needs to be splited into symbols";
char[] symbolsArray = new char[stringToStore.length()];

for(int i=0;i<stringToStore.length();++i){
	symbolsArray[i] = stringToStore.charAt(i);
}
```
@[1](Эту строчку будем разбивать на символы в массив символов)
@[2](Оздаем массив в который мы будем по очереди класть все символы из строки выше. Его размер совпадает с размером строки)
@[4-6](Проходимся по очереди по всем символам строки и кладем по одному символу в массив символов)
@[5](Чтение элемента строки по индексу происходит методом charAt)
+++
@snap[north-west]
Конкатенация
@snapend

@snap[west]
Конкатенация(англ. concatenation) - операция добавления одной строки в конец другой(сложение строк). В Java конкатенацию двух строк модно делать методом `concat()` или через обычный оператор сложения `+`.
@snapend

+++
```Java
Sting stringAtTheBeggining = "Hello";
String space = " ";
String stringAtTheEnd = "world!"

String finalSting = stringAtTheBeggining.concat(space) + stringAtTheEnd;
```
+++
Стоит понимать, что происходит не сложение строк, а создание новой строки. Конкатенация __дорогая__ операция.
+++
@snap[north-west]
Логические методы
@snapend

@snap[west]
@ol
- `equals()` - истина, если две строки равны
- `endWIth()` - истина, если строка заканчивается на эту подстроку
- `startWith()` - истина, если строка начинается с этой подстроки
- `equalsIgnoreCase()` - истина, если две строки равны, игнорируя разницу в регистре
@olend
@snapend

+++
@snap[north-west]
Поиск подстроки
@snapend

@snap[west]
Важной строковой задачей является задача поиска подстроки в строке. С этой проблемой помогают справляться методы:
@ol
- `int indexOf(String str)` - возвращает индекс первого вхождения подстроки в строку или -1, если такой подстроки нет
- `int indexOf(String str, int fromIndex)` - аналогично но, начиная с некоторого индекса
- `int indexOf(int ch)` - аналогично но для символа
- `int indexOf(int ch, int fromIndex)` - аналогично но для символа
@olend
@snapend
+++
@snap[north]
Поиск пробелов в строке
@snapend

```Java
String stringToCheck = "Last time i was in Paris it was raining";

int counter = 0;
int lastIndex = 0;
while(true){
	index = stringToCheck.indexof(" ", lastIndex);
	if(index!=-1){
		lastIndex = index;
		counter++;
	} else
		break;
}
System.out.printf("There are %d spaces in string", counter);
```
@[1](В этой строке мы будем искать пробелы)
@[3-4](В counter будем считать количество пробелов, а в lastindex - индекс последнего пробела)
@[6](Пытаемся найти в строке, начиная с индекса последнего найденого пробела, пробел. Если не найдем получим -1)
@[7-10](Если получили -1, то ничего не делаем и выходим из цикла, если нет, то запоминаем индекс и увеличиваем число пробелов на 1)
+++
@snap[north-west]
Другие важные методы
@snapend

@snap[west]
@ol
- `replaceAll(String substring, String replacement)` - заменяет все подстроки(substring) в строке на указанную подстроку(replacement). Важно, что таким образом можно вырезать фрагмент строки, просто указав в качестве заместительной строки пустую(`""`)
- `split(String devider)` - разбивает строку на массив строк по указанному разделителю. Например. Выбрав в качестве разделителя строку `" "` результатом сплита будет массив подстрок между всеми " ". Строка "Hello world!" таким образом превратится в массив из двух элементов:"Hello" и "world!"
- `subString(int start, int end)` - возвращает подстроку строки, начиная с индекса `start` и заканчивая индексом `end`
- `boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)` - проверяет совпадают ли области двух строк
@olend
@snapend

---
## Enum

+++

Часто возникает проблема, когда  нам необходимо ограничить область допустимых значений некоторых данных. Например мы хотим чтобы некоторая "строковая" переменная могла хранить только определенные значения. Это может быть например переменная, которая хранит в себе название бургера, которое есть в меню. И мы хотим чтобы это переменная __НЕ__ __МОГЛА__ хранить в себе какие-либо название, которых в меню нет.
+++
@snap[north-west]
Enum
@snapend


@snap[west]

В Java существует такой тип данных как __enum__ или __перечисление__. Перечисление -это по своей сути набор логически связанных констант. Объвление идет с помощью специального оператора `enum` после которого идет название объявленного перечисления. В фигурных скобках идет перечисление всех доспустимых значений через запятую<br/>
```
enum NAME{
	VALUE1,
	VALUE2,
	...
	VALUEN
}
```
@snapend 
+++
@snap[north]
Объявление перечисления с днями недели
@snapend

```Java
enum weekDay{
	monday,
	tuesday,
	wednesday,
	thursday,
	friday,
	saturday,
	sunday
}
```
@[1](Объявляем перечисление с именем weekDay)
@[2-8](Указываем все возможные значения enum weekDay через запятую)
+++

@snap[west]
Создавать такие переменные можно очевидныи образом. Значение из числа констант перечеслиния указывается через точку<br/>
 ```
weekDay day = weekDay.monday;
```
@snapend

+++
Какой оператор хорошо сочетается с перечислениями?

+++
@snap[north]
Использоваие enum с switch
@snapend

```Java
switch(day){
	case moday: System.out.ptintln("Отвратительный день!");
	case tuesday: System.out.ptintln("Могло быть лучше");
	case wednesday: System.out.ptintln("Половина недели прошла!");
	case thursday: System.out.ptintln("Завтра пятница!");
	case friday: System.out.ptintln("Ура! Пятница!");
	case saturday: System.out.ptintln("Выходные!");
	case sunday: System.out.ptintln("Завтра понедельник...");
}
```
